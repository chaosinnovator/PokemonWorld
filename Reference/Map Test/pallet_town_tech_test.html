<!DOCTYPE html>
<html>
    <head>
		<meta name="viewport" content="width=device-width,initial-scale=1">
		<link rel="apple-touch-icon" sizes="57x57" href="icon/apple-icon-57x57.png">
		<link rel="apple-touch-icon" sizes="60x60" href="icon/apple-icon-60x60.png">
		<link rel="apple-touch-icon" sizes="72x72" href="icon/apple-icon-72x72.png">
		<link rel="apple-touch-icon" sizes="76x76" href="icon/apple-icon-76x76.png">
		<link rel="apple-touch-icon" sizes="114x114" href="icon/apple-icon-114x114.png">
		<link rel="apple-touch-icon" sizes="120x120" href="icon/apple-icon-120x120.png">
		<link rel="apple-touch-icon" sizes="144x144" href="icon/apple-icon-144x144.png">
		<link rel="apple-touch-icon" sizes="152x152" href="icon/apple-icon-152x152.png">
		<link rel="apple-touch-icon" sizes="180x180" href="icon/apple-icon-180x180.png">
		<link rel="icon" type="image/png" sizes="192x192"  href="icon/android-icon-192x192.png">
		<link rel="icon" type="image/png" sizes="32x32" href="icon/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="96x96" href="icon/favicon-96x96.png">
		<link rel="icon" type="image/png" sizes="16x16" href="icon/favicon-16x16.png">
		<link rel="manifest" href="icon/manifest.json">
		<meta name="msapplication-TileColor" content="#ffffff">
		<meta name="msapplication-TileImage" content="icon/ms-icon-144x144.png">
		<meta name="theme-color" content="#ffffff">
        <title>Pokemon World Technical Test</title>
        <script src="http://code.jquery.com/jquery-3.4.1.min.js"></script>
		<style>
@media screen and (min-width:900px) {
	#mobileControlContainer {
		display: none;
	}
}
		</style>
    </head>
    <body>
        <canvas id="gameCanvas" width="900" height="600" style="border: 1px solid black;"></canvas>
        <div>
            <p>
                Frame:&nbsp;<span id="frame_count">-</span><br />
                Target framerate:&nbsp;<span id="desired_framerate">-</span><br />
                Actual framerate:&nbsp;<span id="framerate">-</span><br />
                Game state:&nbsp;<span id="game_state">-</span>
            </p>
            
            <p>
                Hero position:&nbsp;<span id="hero_pos">-</span><br />
                Camera position:&nbsp;<span id="cam_pos">-</span><br />
                Tile size:&nbsp;<span id="tile_size">-</span>&nbsp;
                <button onclick="tile_width++">Bigger</button>&nbsp;
                <button onclick="tile_width--">Smaller</button><br />
                Resource pack:&nbsp;<span id="selected_pack">-</span>
            </p>
            
            <p>
                Tile animation count:&nbsp;<span id="num_anims">-</span>&nbsp;
                (triggered: <span id="num_triggered_anims">-</span>)<br />
                Entity count:&nbsp;<span id="num_entities">-</span>
            </p>
			<div id="mobileControlContainer" style="position:fixed;bottom:100px;right:100px;">
				<table>
					<tr><td></td><td>
						<button ontouchstart="setControl('yMove-', true);" ontouchend="setControl('yMove-', false);" style="width:10rem;height:10rem;"></button>
					</td><td></td></tr>
					<tr><td>
						<button ontouchstart="setControl('xMove-', true);" ontouchend="setControl('xMove-', false);" style="width:10rem;height:10rem;"></button>
					</td><td></td><td>
						<button ontouchstart="setControl('xMove+', true);" ontouchend="setControl('xMove+', false);" style="width:10rem;height:10rem;"></button>
					</td></tr>
					<tr><td></td><td>
						<button ontouchstart="setControl('yMove+', true);" ontouchend="setControl('yMove+', false);" style="width:10rem;height:10rem;"></button>
					</td><td></td></tr>
				</table>
			</div>
        </div>
        <script>

class PokemonWorldGame {
    canvas = null;
    context = null;
    state = "starting";
// states:
//  starting - initial state
//  loading - loading resources
//  loaded - resources loaded but not playing yet
//  intro - playing game intro/splash screen(s)
//  main_menu - at game menu
//  playing - playing the game
// future:
//  auth_waiting - game waiting for user to sign in to an account
    inputManager;
    resourceManager;
    mapManager;
    entityManager;
    thePlayer;
    
    frame_count = 0;
    last_frame_count = 0;
    desired_framerate = 60;
	framerate = [0];
    gameLoopInterval;
    loop_running = false;
	
	camLockToPlayer = true;
    
    start() {
        this.state = "loading";
        
        this.canvas = document.getElementById("gameCanvas");
        this.context = this.canvas.getContext("2d");
        this.context.imageSmoothingEnabled = false;
        
        this.inputManager = new InputManager();
        window.onkeyup = this.inputManager.keyup.bind(this.inputManager);
        window.onkeydown = this.inputManager.keydown.bind(this.inputManager);
        
        this.resourceManager = new ResourceManager();
        this.mapManager = new MapManager();
        this.entityManager = new EntityManager();
        
        this.thePlayer = new Player(this.inputManager, this.mapManager, 8, 8, 180);
        
        // get resources
        this.resourceManager.loadResources();
        
        // loop
        this.gameLoopInterval = setInterval(this.tick.bind(this), 1000/this.desired_framerate);
    }
    
    tick() {
        if (this.loop_running) {
            console.warn("Too slow! Skipping frame.");
            return;
        }
        this.loop_running = true;
        
        this.inputManager.getInputs();
        
        if (this.state == "starting" || this.state == "loading") {
            this.clear();
            this.context.font = "30px Arial";
            this.context.fillText("Loading... " + this.resourceManager.resources_loaded + "/" + this.resourceManager.resources_to_load, 30, 30);
            if (this.resourceManager.resources_loaded >= this.resourceManager.resources_to_load && this.resourceManager.resources_to_load != 0) {
                this.mapManager.tempLoadSections();
            }
            this.loop_running = false;
            return;
        }
        
        if (this.state == "loaded") {
            this.state = "playing";
        }
        
        if (this.state == "playing") {
            // [components].update();
			this.thePlayer.tick();
			
			if (this.camLockToPlayer) {
				camX = this.thePlayer.position.x;
				camY = this.thePlayer.position.y;
			}
			
            this.clear();
            // [components].draw();
            this.drawMap();
        }
        
        this.frame_count++
        this.loop_running = false;
    }
    
    clear() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    
    drawMap() {
        var layer,x,y,palletId,tileId,frame;
        var left = (this.canvas.width/2)-(camX*tile_width)-(tile_width/2);
        var top = (this.canvas.height/2)-(camY*tile_width)-(tile_width/2);
        //for each section {
            var num_layers = this.mapManager.map_sections[0][0].tile_layers.length;
            var entity_layer = this.mapManager.map_sections[0][0].entity_layer;
            for (layer=0;layer<num_layers;layer++) {
                for (x=0;x<16;x++) {
                    for (y=0;y<16;y++) {
                        palletId = this.mapManager.map_sections[0][0].tile_layers[layer][y][x];
                        tileId = this.mapManager.map_sections[0][0].tile_pallet[palletId];
                        frame = getAnimationFrameOrDefault(0, 0, x, y, layer, tileId);
                        this.context.drawImage(this.resourceManager.resource_pack_assets.tile_textures[tileId][frame], left+(x*tile_width), top+(y*tile_width), tile_width, tile_width);
                    }
                }
                if (layer === entity_layer) {
                    // draw entities
                    // draw player(s)
					var playerTexture;
					switch (this.thePlayer.rotation.z) {
						case 0:
							playerTexture = "gen3:male1_walk_back";
							break;
						case 90:
							playerTexture = "gen3:male1_walk_right";
							break;
						case 180:
							playerTexture = "gen3:male1_walk_front";
							break;
						case 270:
							playerTexture = "gen3:male1_walk_left";
							break;
						default:
					}
					this.context.drawImage(this.resourceManager.resource_pack_assets.player_textures[playerTexture][this.thePlayer.animFrame], left+(this.thePlayer.position.x*tile_width), top+(this.thePlayer.position.y*tile_width)-tile_width, tile_width, 2*tile_width);
                }
            }
        // }
    }
}

class InputManager {
	// TODO: Add gamepad support
	key_state = {};
	control_state = {};
	
	keydown(e) {
		if (this.key_state[e.keyCode]) {
			return;
		}
		this.key_state[e.keyCode] = keyStateEnum.Rising;
	}
	
	keyup(e) {
		this.key_state[e.keyCode] = keyStateEnum.Falling;
	}
	
	getInputs() {
		var control_name, keyCode;
		for (control_name in this.control_map) {
			this.control_state[control_name] = 0;
		    for (keyCode of this.control_map[control_name]) {
				if (this.key_state[keyCode] > this.control_state[control_name]) {
					this.control_state[control_name] = this.key_state[keyCode];
				}
			}
		}
		
		
		for (keyCode in this.key_state) {
			switch (this.key_state[keyCode]) {
				case keyStateEnum.Falling:
					this.key_state[keyCode] = keyStateEnum.Released;
					break;
				case keyStateEnum.Rising:
					this.key_state[keyCode] = keyStateEnum.Pressed;
					break;
				default:
			}
		}
		
		return this.control_state;
	}
	
	
	control_map = {
		"xMove-":[keyEnum.A, keyEnum.LeftArrow],
		"xMove+":[keyEnum.D, keyEnum.RightArrow],
		"xMoveAxis":[],
		"yMove-":[keyEnum.W, keyEnum.UpArrow],
		"yMove+":[keyEnum.S, keyEnum.DownArrow]
	};
}

keyStateEnum = {Released:0, Falling:0.4, Rising:1, Pressed:2}; // numbered such that boolean works if state doesn't matter
keyEnum = {
	Backspace:8,
	Tab:9,
	Enter:13,
	Return:13,
	Shift:16,
	Control:17,
	Alt:18,
	PauseBreak:19,
	CapsLock:20,
	Space:32,
	End:35,
	LeftArrow:37,
	UpArrow:38,
	RightArrow:39,
	DownArrow:40,
	Num1:49,
	A:65,
	D:68,
	S:83,
	W:87,
	X:88,
	WindowsKeyLeft:91,
	WindowsKeyRight:92,
	ContextMenu:93,
	NumPad0:96,
	NumPad1:97,
	F1:112,
	F2:113,
	NumLock:144,
	ScrollLock:145
};

// TEMP/TODO: browser input for mobile
browserControlKeyCodes = {
	"xMove-":keyEnum.LeftArrow,
	"xMove+":keyEnum.RightArrow,
	"yMove-":keyEnum.UpArrow,
	"yMove+":keyEnum.DownArrow
};
function setControl(control_name, state) {
	if (state) {
		pokemonWorldGame.inputManager.keydown({keyCode: browserControlKeyCodes[control_name]});
	} else {
		pokemonWorldGame.inputManager.keyup({keyCode: browserControlKeyCodes[control_name]});
	}
}

class ResourceManager {
    resources_to_load = 0;
    resources_loaded = 0;
    resource_pack_assets = {};
    resource_pack_manifest = {};
    selected_resource_pack = "default";
    resource_pack_manifest;
    
    loadResources() {
        var self = this;
        $.getJSON("resource packs/" + this.selected_resource_pack + "/manifest.json", function(data) {
            self.resource_pack_manifest = data;
            console.log();
            self.loadResourcesFromManifest();
        });
    }
    
    loadResourcesFromManifest() {
        var tileId;
        var tileData;
        this.resources_to_load = Object.keys(this.resource_pack_manifest.tile_textures).length;
        this.resources_loaded = 0;
        this.resource_pack_assets = {};
        this.resource_pack_assets.tile_textures = {};
		this.resource_pack_assets.player_textures = {};
        for (tileId in this.resource_pack_manifest.tile_textures) {
            tileData = this.resource_pack_manifest.tile_textures[tileId];
            if (tileData !== null && typeof tileData === "object") {
                // more complex tile loading
                switch (tileData.type) {
                    case "static":
                        this.loadTileTextures(tileId, tileData.src);
                        break;
                    case "animated":
                        // now we have a multiple tile textures to load
                        this.resources_to_load += (tileData.src.length-1);
                        this.loadTileTextures(tileId, tileData.src);
                        break;
                    default:
                        console.warn("Resource pack '" + this.selected_resource_pack + "': tile '" + tileId + "' doesn't have a valid texture.");
                        this.loadTileTextures(tileId, ["placeholder.png"]);
                }
                continue;
            }
            if (typeof tileData !== "string") {
                // error in pack manifest, also covers null
                console.warn("Resource pack '" + this.selected_resource_pack + "': tile '" + tileId + "' doesn't have a valid texture.");
                // make a placeholder tile image with tileId text on it
                this.loadTileTextures(tileId, ["placeholder.png"]);
                continue;
            }
            // should just be a string representing the texture's src now, shorthand for above 'static' type
            this.loadTileTextures(tileId,[tileData]);
        }
		for (tileId in this.resource_pack_manifest.player_textures) {
            var srcs = this.resource_pack_manifest.player_textures[tileId];
			this.resources_to_load += srcs.length;
			this.resource_pack_assets.player_textures[tileId] = [];
			var self = this;
			var src, img;
			for (src of srcs) {
				img = new Image();
				img.onload = function() {
					self.resources_loaded++;
				}
				img.onerror = function() {
					// make a placeholder tile image with tileId text on it
					this.src = "resource packs/default/placeholder.png";
					console.warn("Resource pack '" + self.selected_resource_pack + "': tile '" + tileId + "' couldn't load texture from " + src + ".");
				}
				img.src = "resource packs/" + this.selected_resource_pack + "/" + src;
				this.resource_pack_assets.player_textures[tileId].push(img);
			}
        }
    }
    
    loadTileTextures(tileId, srcs) {
        var src, img;
        this.resource_pack_assets.tile_textures[tileId] = [];
        var self = this;
        for (src of srcs) {
            img = new Image();
            img.onload = function() {
                self.resources_loaded++;
            }
            img.onerror = function() {
                console.warn("Resource pack '" + self.selected_resource_pack + "': tile '" + tileId + "' couldn't load texture from " + src + ".");
                // make a placeholder tile image with tileId text on it
                this.src = "resource packs/default/placeholder.png";
            }
            img.src = "resource packs/" + this.selected_resource_pack + "/" + src;
            this.resource_pack_assets.tile_textures[tileId].push(img);
        }
    }
}

class MapManager {
    map_sections;
	loadingMapSections = false;
    
    tempLoadSections() {
		if (this.loadingMapSections) {
			return;
		}
		this.loadingMapSections = true;
        this.map_sections = {};
        // get map section 0,0
        var self = this;
        $.getJSON("sections/0-0.json", function(data) {
		console.log("hi");
            self.map_sections[0] = {};
            self.map_sections[0][0] = data;
            pokemonWorldGame.state="loaded";
			this.loadingMapSections = false;
        });
    }
	
	getTileDataAt(x, y) {
		var data = {movement:null,layers:[]}
		var secX = Math.floor(x/16);
		var secY = Math.floor(y/16);
		var layer, palletId;
        var num_layers = this.map_sections[secX][secY].tile_layers.length;
		for (layer=0;layer<num_layers;layer++) {
            palletId = this.map_sections[secX][secY].tile_layers[layer][y][x];
            data.layers.push(this.map_sections[secX][secY].tile_pallet[palletId]);
		}
		palletId = this.map_sections[secX][secY].movement[y][x];
        data.movement = this.map_sections[secX][secY].movement_pallet[palletId];
		return data;
	}
	
	canExitTile(x, y, rot) {
		var rotFlag = 1<<(rot/90);
		var d = this.getTileDataAt(x, y);
		return d.movement.exit & rotFlag === rotFlag;
	}
	
	canEnterTile(x, y, rot) {
		rot = (rot+180)%360;
		var rotFlag = 1<<(rot/90);
		var d = this.getTileDataAt(x, y);
		return d.movement.entry & rotFlag === rotFlag;
	}
}

class EntityManager {
    entities = {};
}

class Player {
    position = {x:0, y:0};
	tile_position = {x:0, y:0};
    rotation = {z:0};
	velocity = {x:0, y:0};
	framesPerTile = {walk:18,run:7,turnCooldown:8,blocked:1};
	turnCooldownThreshold = -2;
	cooldown = 0;
	inputManager;
	mapManager;
	isMoving = false;
	animFrame = 0;
	lastAnim = 0;
	animCooldown = 0;
    
    constructor(inputManager, mapManager, posX, posY, rotZ) {
		this.inputManager = inputManager;
		this.mapManager = mapManager;
        this.position.x = posX;
        this.position.y = posY;
        this.rotation.z = rotZ;
		this.tile_position.x = posX;
		this.tile_position.y = posY;
    }
	
	tick() {
		this.cooldown--;
		this.animCooldown--;
		var selected_speed = this.framesPerTile.walk;
		
		if (this.cooldown <= 0 && this.velocity.x == 0 && this.velocity.y == 0) {
			if (this.inputManager.control_state["yMove-"]) {
				if (!this.rotateTo(0, this.cooldown < this.turnCooldownThreshold)) {
					this.move(selected_speed);
				}
			} else if (this.inputManager.control_state["yMove+"]) {
				if (!this.rotateTo(180, this.cooldown < this.turnCooldownThreshold)) {
					this.move(selected_speed);
				}
			} else if (this.inputManager.control_state["xMove-"]) {
				if (!this.rotateTo(270, this.cooldown < this.turnCooldownThreshold)) {
					this.move(selected_speed);
				}
			} else if (this.inputManager.control_state["xMove+"]) {
				if (!this.rotateTo(90, this.cooldown < this.turnCooldownThreshold)) {
					this.move(selected_speed);
				}
			}
		}
		
		// select animation frame
		if (this.velocity.x != 0 || this.velocity.y != 0) {
			console.log(1);
			var absX = Math.abs(this.position.x%1);
			var absY = Math.abs(this.position.y%1);
			if ((absX > 0.8 || absX < 0.2) && (absY > 0.8 || absY < 0.2)) {
				this.animFrame = 0;
			} else if ((this.tile_position.y+this.tile_position.x)%2) {
				this.animFrame = 1;
				this.lastAnim = 1;
			} else {
				this.animFrame = 2;
				this.lastAnim = 2;
			}
		}
		
		if (this.cooldown <= 0 && this.animCooldown <= 0) {
			this.animFrame = 0;
			this.lastAnim%=100;
		}
		
		if (this.position.x != this.tile_position.x || this.position.y != this.tile_position.y) {
			this.position.x += this.velocity.x;
			this.position.y += this.velocity.y;
		}
		
		if (Math.abs(this.position.x - this.tile_position.x) < Math.abs(this.velocity.x)) {
			this.position.x = this.tile_position.x;
			this.velocity.x = 0;
		}
		
		if (Math.abs(this.position.y - this.tile_position.y) < Math.abs(this.velocity.y)) {
			this.position.y = this.tile_position.y;
			this.velocity.y = 0;
		}
	}
	
	rotateTo(rotZ, requiresCooldown) {
		// returns false if already facing that way, otherwise returns true.
		var oldRotZ = this.rotation.z;
		this.rotation.z = rotZ;
		if (oldRotZ !== rotZ) {
			if (requiresCooldown) {
				this.cooldown = this.framesPerTile.turnCooldown;
			}
			this.animFrame = 1+(this.lastAnim++%2);
			// call an "onRotate" event
			// (will check for interactions)
			return true;
		}
		return false;
	}
	
	move(framesPerTile) {
		var newPos = this.facingPosition();
		if (this.mapManager.canExitTile(this.tile_position.x, this.tile_position.y, this.rotation.x) &&
		    this.mapManager.canEnterTile(newPos.x, newPos.y, this.rotation.x)) {
			this.velocity.x = (newPos.x-this.tile_position.x)*(1/framesPerTile);
			this.velocity.y = (newPos.y-this.tile_position.y)*(1/framesPerTile);
			this.tile_position.x += newPos.x-this.tile_position.x;
			this.tile_position.y += newPos.y-this.tile_position.y;
			this.cooldown = framesPerTile;
		} else {
			this.cooldown = this.framesPerTile.blocked;
			this.animFrame = [1, 0, 2, 0][Math.floor(this.lastAnim++/this.framesPerTile.walk)%4];
			this.animCooldown = this.framesPerTile.walk;
			// Play sound for hitting barrier
		}
	}
	
	facingPosition() {
		var p = {x:this.tile_position.x,y:this.tile_position.y};
		switch (this.rotation.z) {
			case 0:
				p.y--;
				break;
			case 90:
				p.x++;
				break;
			case 180:
				p.y++;
				break;
			case 270:
				p.x--;
				break;
			default:
		}
		//p.tile = this.mapManager.getTileDataAt(p.x, p.y);
		return p;
	}
}

var our_player_id = "testid";
var tile_width = 32;
var camX = 8;
var camY = 8;
var debugInterval;
var num_animations = 0;
var num_triggered_animations = 0;
var num_entities = 0;
var animations = {};
var entities = {};

function frCheck() {
    pokemonWorldGame.framerate.push((pokemonWorldGame.frame_count-pokemonWorldGame.last_frame_count)*10);
    pokemonWorldGame.last_frame_count = pokemonWorldGame.frame_count;
	var l = pokemonWorldGame.framerate.length;
	var fr = 0;
	if (l >= 10) {
		for (var i = 0; i < l; i++) {
			fr += pokemonWorldGame.framerate[i];
		}
		fr = fr/l;
		pokemonWorldGame.framerate.shift();
	}
    $("#framerate").text(fr);
    $("#framerate").css("color", fr < pokemonWorldGame.desired_framerate ? "#FF0000" : "#000000");
}

function updateDebug() {
    var secX, secY;
    
    $("#frame_count").text(pokemonWorldGame.frame_count);
    $("#desired_framerate").text(pokemonWorldGame.desired_framerate);
    $("#game_state").text(pokemonWorldGame.state);
    
	pSecX = Math.floor(pokemonWorldGame.thePlayer.position.x/16);
    pSecY = Math.floor(pokemonWorldGame.thePlayer.position.y/16);
    secX = Math.floor(camX/16);
    secY = Math.floor(camY/16);
    
    $("#hero_pos").text("x: "+pokemonWorldGame.thePlayer.position.x+" x: "+pokemonWorldGame.thePlayer.position.y+" sx: "+pSecX+" sy: "+pSecY);
    $("#cam_pos").text("x: "+camX+" x: "+camY+" sx: "+secX+" sy: "+secY);
    $("#tile_size").text(tile_width);
    $("#selected_pack").text(pokemonWorldGame.selected_resource_pack);
    
    $("#num_anims").text(num_animations);
    $("#num_triggered_anims").text(num_triggered_animations);
    $("#num_entities").text(num_entities);
}


function getAnimationFrameOrDefault(sx, sy, x, y, layer, tileId) {
    if (pokemonWorldGame.resourceManager.resource_pack_manifest.tile_textures[tileId] == null) {
        return 0;
    }
    if (pokemonWorldGame.resourceManager.resource_pack_manifest.tile_textures[tileId].type != "animated") {
        return 0;
    }
    
    animKey = "" + sx + "-" + sy + "-" + x + "-" + y + "-" + layer;
    
    if (!(animKey in animations)) {
        animations[animKey] = {
            trigger: pokemonWorldGame.resourceManager.resource_pack_manifest.tile_textures[tileId].trigger,
            frame_time: pokemonWorldGame.resourceManager.resource_pack_manifest.tile_textures[tileId].frame_time,
            repeat: pokemonWorldGame.resourceManager.resource_pack_manifest.tile_textures[tileId].repeat,
            numFrames: pokemonWorldGame.resourceManager.resource_pack_manifest.tile_textures[tileId].src.length,
            currentFrame: 0,
            currentFrameCounter: 0,
            plays: 0,
            triggered: false,
            triggered_by: null
        }
        num_animations++;
    }
    
    if (!animations[animKey].triggered && animations[animKey].trigger == "load") {
        animations[animKey].triggered = true;
        num_triggered_animations++;
    }
    
    if (animations[animKey].triggered) {
        animations[animKey].currentFrameCounter++;
        if (animations[animKey].currentFrameCounter > animations[animKey].frame_time) {
            animations[animKey].currentFrame++;
            animations[animKey].currentFrameCounter = 0;
        }
    }
    
    if (animations[animKey].currentFrame >= animations[animKey].numFrames) {
        animations[animKey].currentFrame%=animations[animKey].numFrames;
        if (animations[animKey].repeat != 0) {
            if (animations[animKey].plays++ >= animations[animKey].repeat) {
                animations[animKey].triggered = false;
                num_triggered_animations--;
            }
        }
    }
    
    return animations[animKey].currentFrame;
}

var pokemonWorldGame;

$(document).ready(function() {
    pokemonWorldGame = new PokemonWorldGame();
    pokemonWorldGame.start();
    debugInterval = setInterval(function() {frCheck(); updateDebug();}, 100);
});
        </script>
    </body>
</html>